## 冒泡排序
冒泡排序（BubbleSort）是一种简单直观的算法。它需要重复的走过未完成排序的序列，一次比较两个元素，假如两者失序就交互顺序，直到走过的序列没有需要交换的元素，就可以认为排序已经完成。这种排序进行的时候，每走过一轮序列，就会找到一个最大值，因此较小的元素是逐渐浮到序列的顶端，因此称冒泡。

冒泡可以设置一个flag，当一趟排序没有发生元素交换的时候就证明该序列已经有序了，这种改进算法无法减小其复杂度，对提升性能没有太大的作用。

### 算法步骤
* 比较相邻的元素，如果序列靠前的较大，就交换他们
* 按顺序对每一对相邻的元素执行相同的工作，直到最后一轮，这部完成后，最后的元素就是最大的数
* 除最后一个元素，对其他元素重复以上步骤
* 持续对越来越少的未完成排序的元素重复上面的步骤，知道没有一对元素需要比较

### 动图演示

![](https://github.com/hustcc/JS-Sorting-Algorithm/raw/master/res/bubbleSort.gif)

### 复杂度分析
冒泡在正序时最快，逆序时最慢，算法复杂度为O(n^2)

## 选择排序
选择排序（Selection Sort）是一种简单直观的排序算法，无论什么数据进去，都是相同的O(n^2)的复杂度，数据规模越小越好，但是不会增大空间复杂度

### 算法步骤
* 在未排序的序列中找到最小的元素，放在排序序列的起始位置
* 从剩余未排序的元素中寻找最小元素，放在已排序序列的末尾
* 重复第二步，直到所有元素均排序完成

### 动图演示
![](https://github.com/hustcc/JS-Sorting-Algorithm/raw/master/res/selectionSort.gif)
### 复杂度分析
无好坏情况，都是O(n^2)

## 插入排序
插入排序和打扑克排的操作很类似，通过构建有序序列，从后向前扫描已排序的序列，将未排序的序列依次插入相应的位置

插入算法有一种优化算法，**拆半插入**

### 算法步骤
* 将待排序序列的第一个元素看作一个有序序列，将其余元素看作待排序序列
* 从头到尾扫描未排序序列，将扫描到的每个元素插入到有序序列的适当位置，如果待插入的元素和某个有序序列的元素相等，则直接将待插入元素放到相等元素的后面

### 动图演示
![](https://github.com/hustcc/JS-Sorting-Algorithm/raw/master/res/insertionSort.gif)

### 复杂度分析
O(n^2),最好情况是O(n)

## 希尔排序
希尔排序，也称缩小增量排序算法，是插入排序的一种更高效的改进版本，同时也是冲破O(n^2)的第一批算法。但希尔排序是非稳定排序算法。插入排序对几乎已经排好的序列很高效，几乎可以达到线性复杂度；但是对于一般的序列是低效的，因为插入排序每次只能将数据移动一位。

希尔排序的思想是：先将整个待排序列分割成若干子序列分别直接插入序列，待整个序列中记录基本有序时再对全部记录依次直接插入排序，

### 算法步骤
* 选择一个增量序列（t1,t2....,tk）,其中ti>tj,tk=1
* 按照增量序列的个数k，对序列进行k趟排序
* 每趟排序，根据对应的增量ti,将待排序序列分割成若干长度为m的子序列，分别对各个子表进行直接插入排序，仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度

在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为**增量序列**。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。


### 复杂度分析
希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2,(n/2)/2...1}(希尔增量)，其最坏时间复杂度依然为O(n^2)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n^3/2)。

## 归并排序
归并排序（Merge Sort）是建立在归并操作上的一种有效的排序算法，是采用分治法（Divide and Conquer）的一个非常典型的应用

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：
* 自上而下的递归，所有递归的方法都可以使用迭代重写
* 自下而上的迭代

在《数据结构与算法JavaScript描述》中，作者认为：
> However,it is not possible to do so in Javascript,as the recursion goes too deep for the language to handle.(这种递归深度对js而言，还是太深了)

归并排序和选择排序一样，不受输入数据的影响，但是其时间复杂度却好得多，其时间复杂度都是O(nlogn)的时间复杂度，但是需要额外的空间复杂度

### 算法步骤
* 申请空间，使得其大小为两个已排序序列之和，该空间用来存放合并后的序列
* 设定两个指针，初始位置分别为两个已经排序序列的其实位置
* 比较两个指针指向的元素，选择相对较小的放入合并区间，并移动指针到下一位置
* 重复步骤三，直到某一指针达到序列尾
* 将另一序列剩下的所有元素直接复制到合并序列尾

### 动图演示


